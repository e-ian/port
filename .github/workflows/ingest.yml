name: Ingest YouTube Playlist

on:
  schedule:
    - cron: "0 0 * * *"  # Runs daily at midnight UTC
  workflow_dispatch:      # Allows manual triggering

jobs:
  ingest-youtube-data:
    runs-on: ubuntu-latest
    
    env:
      YOUTUBE_API_KEY: ${{ secrets.YOUTUBE_API_KEY }}
      PORT_API_KEY: ${{ secrets.PORT_API_KEY }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install google-api-python-client requests
    
    - name: Run YouTube Port ingestion
      run: |
        python << 'EOF'
        import os
        import logging
        import requests
        from googleapiclient.discovery import build
        from datetime import datetime
        import sys

        # Set up logging
        logging.basicConfig(level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            stream=sys.stdout
        )
        logger = logging.getLogger(__name__)

        class YouTubePortIngestion:
            def __init__(self):
                self.PLAYLIST_ID = 'PL5ErBr2d3QJH0kbwTQ7HSuzvBb4zIWzhy'
                self.port_api_url = "https://api.getport.io/v1"
                self.port_api_key = os.environ['PORT_API_KEY']
                self.playlist_blueprint_identifier = "playlist"
                self.video_blueprint_identifier = "video"
                try:
                    self.youtube = build('youtube', 'v3', developerKey=os.environ['YOUTUBE_API_KEY'])
                    logger.info("Successfully initialized YouTube client")
                except KeyError as e:
                    logger.error(f"Missing environment variable: {str(e)}")
                    raise
                except Exception as e:
                    logger.error(f"Error initializing clients: {str(e)}")
                    raise

            def fetch_playlist_info(self):
                try:
                    playlist_response = self.youtube.playlists().list(
                        part='snippet,contentDetails',
                        id=self.PLAYLIST_ID
                    ).execute()
                    
                    if not playlist_response.get('items'):
                        raise Exception(f"No playlist found with ID {self.PLAYLIST_ID}")
                    
                    playlist = playlist_response['items'][0]
                    playlist_data = {
                        'identifier': self.PLAYLIST_ID,
                        'properties': {
                            'title': playlist['snippet']['title'],
                            'description': playlist['snippet']['description'],
                            'thumbnailUrl': playlist['snippet']['thumbnails']['default']['url'],
                            'videoCount': playlist['contentDetails']['itemCount']
                        }
                    }
                    logger.info(f"Fetched playlist data: {playlist_data}")
                    return playlist_data
                except Exception as e:
                    logger.error(f"Error fetching playlist info: {str(e)}")
                    raise

            def fetch_video_details(self, video_id):
                try:
                    video_response = self.youtube.videos().list(
                        part='statistics,contentDetails,snippet',
                        id=video_id
                    ).execute()
                    return video_response['items'][0] if video_response.get('items') else None
                except Exception as e:
                    logger.error(f"Error fetching video details for {video_id}: {str(e)}")
                    return None

            def update_or_create_entity(self, entity_data, blueprint_identifier):
                url = f"{self.port_api_url}/blueprints/{blueprint_identifier}/entities"
                headers = {
                    'Authorization': f"Bearer {self.port_api_key}",
                    'Content-Type': 'application/json'
                }

                logger.info(f"Attempting to create/update entity with data: {entity_data}")

                # Check if the entity already exists
                existing_entity = self.get_entity(entity_data['identifier'], blueprint_identifier)
                
                if existing_entity:
                    logger.info(f"Updating existing entity with ID {entity_data['identifier']}")
                    response = requests.patch(f"{url}/{entity_data['identifier']}", json=entity_data, headers=headers)
                else:
                    logger.info(f"Creating new entity with ID {entity_data['identifier']}")
                    response = requests.post(url, json=entity_data, headers=headers)
                
                if response.status_code not in [200, 201]:
                    logger.error(f"Error {response.status_code}: {response.text}")
                    raise Exception(f"Failed to create or update entity: {response.text}")
                else:
                    logger.info(f"Successfully handled entity with ID {entity_data['identifier']}")

            def get_entity(self, entity_id, blueprint_identifier):
                url = f"{self.port_api_url}/blueprints/{blueprint_identifier}/entities/{entity_id}"
                headers = {
                    'Authorization': f"Bearer {self.port_api_key}",
                    'Content-Type': 'application/json'
                }

                response = requests.get(url, headers=headers)
                if response.status_code == 200:
                    return response.json()
                elif response.status_code == 404:
                    return None
                else:
                    logger.error(f"Error {response.status_code}: {response.text}")
                    raise Exception(f"Failed to fetch entity with ID {entity_id}")

            def process_videos(self, playlist_id):
                try:
                    next_page_token = None
                    while True:
                        video_response = self.youtube.playlistItems().list(
                            part='snippet,contentDetails',
                            playlistId=playlist_id,
                            maxResults=50,
                            pageToken=next_page_token
                        ).execute()
                        
                        for item in video_response['items']:
                            video_id = item['contentDetails']['videoId']
                            video_details = self.fetch_video_details(video_id)
                            
                            if video_details:
                                video_data = {
                                    'identifier': video_id,
                                    'properties': {
                                        'title': item['snippet']['title'],
                                        'description': item['snippet']['description'],
                                        'thumbnailUrl': item['snippet']['thumbnails']['default']['url'],
                                        'duration': video_details['contentDetails']['duration'],
                                        'viewCount': int(video_details['statistics'].get('viewCount', 0)),
                                        'likeCount': int(video_details['statistics'].get('likeCount', 0)),
                                        'commentCount': int(video_details['statistics'].get('commentCount', 0))
                                    },
                                    'relations': {
                                        'playlist': playlist_id
                                    }
                                }
                                
                                self.update_or_create_entity(video_data, self.video_blueprint_identifier)
                        
                        next_page_token = video_response.get('nextPageToken')
                        if not next_page_token:
                            break
                except Exception as e:
                    logger.error(f"Error processing videos: {str(e)}")
                    raise

            def run(self):
                try:
                    logger.info(f"Starting ingestion at {datetime.now()}")
                    
                    # Process playlist
                    playlist_data = self.fetch_playlist_info()
                    self.update_or_create_entity(playlist_data, self.playlist_blueprint_identifier)
                    
                    # Process videos
                    self.process_videos(self.PLAYLIST_ID)
                    
                    logger.info(f"Completed ingestion at {datetime.now()}")
                except Exception as e:
                    logger.error(f"Ingestion failed: {str(e)}")
                    raise

        if __name__ == "__main__":
            try:
                logger.info("Starting YouTube Port ingestion process")
                ingestion = YouTubePortIngestion()
                ingestion.run()
                logger.info("Successfully completed YouTube Port ingestion")
            except Exception as e:
                logger.error(f"Fatal error in main execution: {str(e)}")
                sys.exit(1)
        EOF
